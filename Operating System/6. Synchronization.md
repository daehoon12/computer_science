# Synchronization

## Background  
- 독립적인 프로세스들이 동시에 공유 메모리에 접근 하는 것은 data의 inconsistency를 야기함.  
- 여러 프로세스들이 공유하는 데이터를 **Shared Data (Critical Data)** 라고 한다.  
- 공유 데이터를 접근하는 코드 영역을 **Critical Section** 이라고 한다.  
- 두 개 이상의 프로세스가 동시에 **Critical Section** 에 진입하는 것을 막는 것을 **Mutual Exclusion** 이라 한다.  

## Critical-Section Problem  
- 누가 먼저 Shared Data를 접근할까?  
- 누가 접근하고 있는지 어떻게 알까?  
- 어떤 순서로 접근할까?  

### Critical Section - Solution  
1. Mutual Exclusion : 하나의 프로세스가 **Critical Section** 안에 있으면 다른 프로세스는 들어올 수 없다.  
2. Progress : 대기 시간이 한 없이 길어지면 안됨.  
3. Bounded Waiting : 들어오기 원하는 것이 있으면 허용하되, 허용 횟수는 정해져 있음.  

### Peterson's Algorithm (SW Solution)  
- 두 개의 프로세스의 Solution을 제공  
- 차례와 누가 준비되어 있는지를 나타내는 두 개의 변수 사용 (int turn, bool flag[2])  
- flag는 turn과 다른 process id를 가리키고 있음. (flag[i] = true == Process Pi is ready!)  
- 다수의 프로세스에서 사용이 어렵다.  
- **Busy Waiting**이 발생해 효율적이진 않음.  

![9](https://user-images.githubusercontent.com/32921115/99218250-562ec380-281d-11eb-8a18-add7149a89e9.PNG)

### Synchronization Hardward (HW Solution)  
- Lock을 통해 Synchronization을 구현  
- **Atomic (non-interrunptible)** 한 방법  

<img src="/Operating System/캡처/10.PNG" width="50%" height="50%">  

#### test_and_set Instruction  

<img src="/Operating System/캡처/11.PNG" width="50%" height="50%">

1. rv에 target을 기록  
2. target에 true를 세팅하고 값을 반환.  

<img src="/Operating System/캡처/12.PNG" width="50%" height="50%">

- 3개 이상의 process가 존재하는 경우, **bounded waiting 조건을 만족 시키지 못함**  
- **compare_and_swap()**을 통한 해결  

<img src="/Operating System/캡처/13.PNG" width="50%" height="50%">
