# Synchronization

## Background  
- 독립적인 프로세스들이 동시에 공유 메모리에 접근 하는 것은 **data의 inconsistency**를 야기함.  
- 여러 프로세스들이 공유하는 데이터를 **Shared Data (Critical Data)** 라고 한다.  
- 공유 데이터를 접근하는 코드 영역을 **Critical Section** 이라고 한다.  
- 두 개 이상의 프로세스가 동시에 **Critical Section** 에 진입하는 것을 막는 것을 **Mutual Exclusion** 이라 한다.  

## Critical-Section Problem  
- 누가 먼저 Shared Data를 접근할까?  
- 누가 접근하고 있는지 어떻게 알까?  
- 어떤 순서로 접근할까?  

### Critical Section - Solution  
1. Mutual Exclusion : 하나의 프로세스가 **Critical Section** 안에 있으면 다른 프로세스는 들어올 수 없다.  
2. Progress : 대기 시간이 한 없이 길어지면 안됨.  
3. Bounded Waiting : 들어오기 원하는 것이 있으면 허용하되, 허용 횟수는 정해져 있음.  

### Peterson's Algorithm (SW Solution)  
- 두 개의 프로세스의 Solution을 제공  
- 차례와 누가 준비되어 있는지를 나타내는 두 개의 변수 사용 (int turn, bool flag[2])  
- flag는 turn과 다른 process id를 가리키고 있음. (flag[i] = true == Process Pi is ready!)  
- 다수의 프로세스에서 사용이 어렵다.  
- **Busy Waiting**이 발생해 효율적이진 않음.  

![9](https://user-images.githubusercontent.com/32921115/99218250-562ec380-281d-11eb-8a18-add7149a89e9.PNG)

### Synchronization Hardward (HW Solution)  
- Lock을 통해 Synchronization을 구현  
- **Atomic (non-interrunptible)** 한 방법  

![10](https://user-images.githubusercontent.com/32921115/99218281-66df3980-281d-11eb-8417-1f2832334b3f.PNG) 

#### test_and_set Instruction  
![11](https://user-images.githubusercontent.com/32921115/99218284-69da2a00-281d-11eb-9c50-2616a1313361.PNG)  

1. rv에 target을 기록  
2. target에 true를 세팅하고 값을 반환.  

![12](https://user-images.githubusercontent.com/32921115/99218286-6a72c080-281d-11eb-8568-e61584cbfa55.PNG)

- 3개 이상의 process가 존재하는 경우, **bounded waiting 조건을 만족 시키지 못함**  
- **compare_and_swap()** 을 통한 해결  

![13](https://user-images.githubusercontent.com/32921115/99218290-6ba3ed80-281d-11eb-8962-a293eef6d157.PNG)

### Mutex Lock (OS Solutuon)  
- **OS Level**에서 **Critical Section Problem**을 해결하기 위한 Software tools  
- **Busy Waiting**이 발생하지만, **Context Switching**을 하지 않아도 되는 메커니즘으로 **멀티 코어 시스템**에서는 장점.  
(사진)

### Semaphore (OS Solution)  
- Mutex Lock보다 더 복잡한 방법으로 Process 간 Synchronization 제공  
- wait(s)는 조건에 맞을 때까지 기다리다가 ready queue 하나를 감소 시키고, critical section으로 들어감. 다 실행하면 signal(s)을 실행해 ready queue 하나를 증가 시킨다.  
- 여러 개를 한번에 관리할 수 있는 유연한 System을 제공함.  
(사진)  
- Wait()와 signal()을 동시에 실행하지 못하게 해야 한다. (교착 상태 발생)  

### Monitors (Language Level Solution)  
- 세마포어는 잘못된 알고리즘을 설계 하면 deadlock 현상이 발생함  
- 모니터는 프로그래머가 정의한 함수에 Mutual Exclusion을 제공  
- 모니터 안에서는 항상 하나의 프로세스만 running 가능  

ex) condition x에서 Process P가 block 상태면, 다른 프로세스가 x.signal()을 해줄 때 까지 P는 계속 쉬는 상태. Process P를 깨워주는 Process를 Q라고 가정하자.  

여기서 P가 x.signal()을 해 Process Q를 깨웠다면 2가지 선택지가 생김.  
1. Signal and Wait : 살아난 프로세스 Q가 모니터를 떠날 때 까지 프로세스 P는 실행을 연기함  
2. Signal and continue : 살아난 프로세스 Q가 살려준 프로세스 P가 모니터를 떠날때까지 실행을 연기함  

#### Condition Variables  
- 만약 Running중인 Process가 I/O Interrupt를 만나 I/O 작업을 하게 되면, Process는 혼자 모니터를 점유하는 상태  
- 이런 프로세스를 condition queue에 넣어 재우다가 다시 running할 줄비가 되면 깨워주기 전까지 보관하는 역할을 수행함.  
- condition x,y  
 - 프로세스를 재우고 싶다. x.wait(), y.wait()  
 - 프로세스를 깨우고 싶다. x.signal(), y.signal()  
 
## Deadlock and Starvation  

### Deadlock  
- 무한하게 계속 waiting을 함.  
(사진)  

### Starvation  
- 우선순위가 너무 낮은 Process들은 영원히 Critical Section에 들어 갈 수 없어, Process들이 세마포어 큐에서 영원히 지워지지 않는 현상  
- Priority Inversion 현상이 발생한다. (Lower-priorty process가 lock을 잡으면 스케쥴러의 선택을 받지 못해 Critical Section에 들어갈 수 없어 다른 Process들이 실행이 되지 않는다.)  

## Implementing a Monitor Using Semaphores.  
- 세마포어를 사용해 모니터를 발생.  
- 각 모니터마다 mutex라는 세마포어 정의되고 초기 값은 1
