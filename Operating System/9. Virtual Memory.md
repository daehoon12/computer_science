# Virtual Memory

## Background  
- 우리가 구동하려는 프로그램은 Memory보다 더 크다면?  
- 기본 아이디어 : 메모리가 더 많이 존재하는 것 처럼 보이게 하자  
- 메모리 크기 제약에 자유로워 질수 있으나, 구현이 어렵고 잘못 사용하면 성능 저하가 심하다.  
- Virtual Memory는 Secondary Storage에 존재  
- Main Memory에는 Process의 필요한 부분만 있으면 된다.  
- Virtual Memory에서 MMU를 통해 필요한 부분만 Physical Memory로 올라가고 나머지는 저장되어 있음.  


## Virtual Memory  
- Physical Memory와 User logical Memory의 분리  
- Virtual Address : Process에서 참조하는 주소  
- Physical Address : Main Memory에 있는 사용 가능한 주소  
- Memory Management Unit (MMU) : 가상 주소를 물리 주소로 빠르게 매핑

## Virtual Address Space  
- MAX로부터 Stack이 증가, Heap은 반대 방향으로 올라감.  
![image](https://user-images.githubusercontent.com/32921115/101123105-66290e80-3637-11eb-8237-b155f33ec0d3.png)

 ## Valid-Invlid Bit  
 - v : In Physical Memory, i : not in memory   
 ![image](https://user-images.githubusercontent.com/32921115/101126271-78f31180-363e-11eb-8f93-4e0cb244b4ea.png)
- 사진에서 A - H은 프로그램을 구성하는 code  
- A, C, F가 Physical Memory에 올라와 있고, 나머지는 Virtual Memory에 있는 상황  
- 만약에 D가 메모리에 올라와 있지 않은 곳에 접근하면 **Page Fault 발생**  

## Page Fault  
-  page가 page table을 통해 주소변환을 하는 과정에서 invalid bit를 발견 했을 때, OS에게 Tra을 거는 현상  
- Invalid Page에 대한 Reference라면 Process를 중단, 단순히 Page가 메모리에 올라오지 않았다면, 디스크로부터 가져온다.  
- 빈 공간, 즉 Free Frame을 찾는다.  
- 디스크에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청  
- 다 읽었으면, Page Table을 갱신한다 (i -> v)  
- Trap에 의해 중단되었던 명령어를 다시 수행한다. (Restart Instruction)  
![image](https://user-images.githubusercontent.com/32921115/101126727-6c22ed80-363f-11eb-808a-1224490fd3a5.png)

### Stage in Demand Paging (Worse Case)  
1. OS에게 트랩을 건다.  
2. 현재 User registers, Process State 저장  
3. page fault가 왜 일어났는지 본다.  
4. 참조할수 없는 곳을 참조했으면 Process 중단하고, 단순히 메모리에 올라오지 않으면 디스크에서 찾는다.  
5. 디스크에서 빈 frame으로 올린다.  
6. 4,5이 끝날때 까지 CPU는 다른 Process Job을 한다.  
7. 4,5가 끝나면 CPU에게 I/O Completed 인터럽트를 보낸다.  
8. 다른 Job의 상태를 저장  
9. 디스크의 인터럽트를 확인한다.  
10. Page Table을 갱신한다.  
11. CPU는 저장했던 것 그대로 Reload.  
12. Restore하고 멈췄던 Interrupted가 걸렸던 시점부터 다시 시작한다. (Instruction Restart)  
