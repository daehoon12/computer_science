# Virtual Memory

## Background  
- 우리가 구동하려는 프로그램은 Memory보다 더 크다면?  
- 기본 아이디어 : 메모리가 더 많이 존재하는 것 처럼 보이게 하자  
- 메모리 크기 제약에 자유로워 질수 있으나, 구현이 어렵고 잘못 사용하면 성능 저하가 심하다.  
- Virtual Memory는 Secondary Storage에 존재  
- Main Memory에는 Process의 필요한 부분만 있으면 된다.  
- Virtual Memory에서 MMU를 통해 필요한 부분만 Physical Memory로 올라가고 나머지는 저장되어 있음.  


## Virtual Memory  
- Physical Memory와 User logical Memory의 분리  
- Virtual Address : Process에서 참조하는 주소  
- Physical Address : Main Memory에 있는 사용 가능한 주소  
- Memory Management Unit (MMU) : 가상 주소를 물리 주소로 빠르게 매핑

## Virtual Address Space  
- MAX로부터 Stack이 증가, Heap은 반대 방향으로 올라감.  
![image](https://user-images.githubusercontent.com/32921115/101123105-66290e80-3637-11eb-8237-b155f33ec0d3.png)

 ## Valid-Invlid Bit  
 - v : In Physical Memory, i : not in memory   
 ![image](https://user-images.githubusercontent.com/32921115/101126271-78f31180-363e-11eb-8f93-4e0cb244b4ea.png)
- 사진에서 A - H은 프로그램을 구성하는 code  
- A, C, F가 Physical Memory에 올라와 있고, 나머지는 Virtual Memory에 있는 상황  
- 만약에 D가 메모리에 올라와 있지 않은 곳에 접근하면 **Page Fault 발생**  

## Page Fault  
-  page가 page table을 통해 주소변환을 하는 과정에서 invalid bit를 발견 했을 때, OS에게 Tra을 거는 현상  
- Invalid Page에 대한 Reference라면 Process를 중단, 단순히 Page가 메모리에 올라오지 않았다면, 디스크로부터 가져온다.  
- 빈 공간, 즉 Free Frame을 찾는다.  
- 디스크에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청  
- 다 읽었으면, Page Table을 갱신한다 (i -> v)  
- Trap에 의해 중단되었던 명령어를 다시 수행한다. (Restart Instruction)  
![image](https://user-images.githubusercontent.com/32921115/101126727-6c22ed80-363f-11eb-808a-1224490fd3a5.png)

### Stage in Demand Paging (Worse Case)  
1. OS에게 트랩을 건다.  
2. 현재 User registers, Process State 저장  
3. page fault가 왜 일어났는지 본다.  
4. 참조할수 없는 곳을 참조했으면 Process 중단하고, 단순히 메모리에 올라오지 않으면 디스크에서 찾는다.  
5. 디스크에서 빈 frame으로 올린다.  
6. 4,5이 끝날때 까지 CPU는 다른 Process Job을 한다.  
7. 4,5가 끝나면 CPU에게 I/O Completed 인터럽트를 보낸다.  
8. 다른 Job의 상태를 저장  
9. 디스크의 인터럽트를 확인한다.  
10. Page Table을 갱신한다.  
11. CPU는 저장했던 것 그대로 Reload.  
12. Restore하고 멈췄던 Interrupted가 걸렸던 시점부터 다시 시작한다. (Instruction Restart)  

## Performane of Demand Paging  
- p =0 : no page faults, p=1 : every reference is fault  
- Effective Access Time (EAT) = (1 - p) x memory access + p(page fault overhead + swap page out + swap page in)  

## Demand Paging Optimizations  
- Damand Paging의 특성 중 하나는 Swap 공간의 관리이다.  
- 일반적으로 Swap Space의 I/O는 File System에서의 I/O보다 빠르다.  
- 그러므로 시스템은 한 프로세스를 실행시킬 때, File Image를 Swap Space로 복사한 후, 거기서 Demand Paging을 처리함으로써 보다 나은 **Page Throughput**을 얻을 수 있다.  
- 프로그램을 처음 실행 시킬 때 File System으로부터 Damand Paging을 처리하지만, 그 Page들이 교체 될때는 Swap Space에 Page를 기록한다.  
-모바일은 Swapping을 지원하지 않는다.대신 File System으로 Demand paging을하고 메모리가 부족하면 읽기 전용 페이지들을 방출함.

## Copy-on-Write  
- fork()는 Parent Process의 Pages를 Child Process에 복사함으로 Child Process의 Address Space를 구성함. But, 대부분의 Child Process는 곧 exec()을 호출한다. 그래서 Parent의 Page를 다 복사하는 대신 Copy-on-Write를 사용함  
- Child Process가 시작할 때 Parent's Page를 당분간 함께 사용 가능하도록 한다. 이때 공유되는 Page를 **Copy-on-Write Page**라 한다.  
- 즉 공유를 하되, Demand Paging만 Copy해서 쓴다.  
![image](https://user-images.githubusercontent.com/32921115/101129881-c6bf4800-3645-11eb-89f0-9e1bdbf64970.png)
![image](https://user-images.githubusercontent.com/32921115/101129943-e8b8ca80-3645-11eb-9248-3228f696eaba.png)

## What happens if there is no free frame?  
- Process Pages들이 다 점유했거나, kernel, I/O device에서 다 점유했을 때 free frame이 없을 수 있음.  
- Page Replacement : 자주 사용되지 않은 page를 찾아 memory에서 빼낸다.  

## Page Replacement - a basic routine  
1. 디스크에 요구된 page를 찾는다.  
2. free frame을 찾는다. free frame이 없을 때, **Page replacement algorithm**을 사용해 **victim frame**을 고른다. 고른 뒤 victim frame을 disk에 쓴다. (Swapping)  
3. free frame이 생기고 요구된 page를 frame으로 올린다.  
4. trap이 발생한 지점부터 다시 시작한다.  
- 2 page transfers 발생.
![image](https://user-images.githubusercontent.com/32921115/101131320-6e3d7a00-3648-11eb-879a-20a9fe2cdf8b.png)

### Benefit  
- Over allocation을 방지  
- modify(dirty) bit를 사용해 page transfers의 overhead를 줄인다.  
 
## Two Important Problems in page Replacement  
1. Frame-allocation algorithm : 여러 프로세스가 존재하는 경우 각 프로세스에 얼마나 많은 프레임을 할당해야할지 결정해야 한다.    
2. Page-replacement Algorithm : 페이지 교체가 필요할 때마다 어떤 페이지를 교체해야 할지 결정해야 한다.  

### First-in-First-Out (FIFO) Algorithm  
![image](https://user-images.githubusercontent.com/32921115/101133396-025d1080-364c-11eb-949c-aa187c4a8ae5.png)
- 가장 먼저 들어온 page를 교체한다.  
