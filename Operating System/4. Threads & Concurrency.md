# Threads & Concurrency  

## Thread  
- 프로세스의 처리속도를 높이기 위해 하나의 프로세스가 수행해야 할 여러 작업들을 나누어 수행할 수 있도록 설계된 것.  
- 한 프로세스에 존재하는 모든 스레드들은 프로세스의 상태 (Heap, Data, Code)를 공유한다. 즉, 스레드간의 별도의 통신이 필요하지 않다. (프로세스는 IPC필요)  

## Multithreading Models

### Many-to-One    
- 여러 개의 User thread가 하나의 kernel thread에 mapping.  
- 병목현상 발생.  

### One-to-One  
- 하나의 유저 - 하나의 커널  
- Many-to-One보다 병행성이 큼  
- 하나의 프로세스 안에 너무 많은 스레드가 있으면, 다른 프로세스가 작업을 못하는 경우가 있어 Overhead 발생.  
### Many-to-Many  
- 관리가 힘들어짐.   

## Thread Library   
- 프로그래머에게 Thread를 관리하는 API를 제공  
- 보통 User Space에서 제공 되지만, 커널 레벨 라이브러리는 OS가 제공  

## Implicit Threading  
- thread의 생성과 관리를 프로그래머가 아닌 컴파일러와 런타임 라이브러리에서 해준다.  
- thread의 생성과 관리를 시스템에서 해주고 application은 thread를 쉽게 활용할 수 있게 library에서 제공해준다.  
- explicit threading은 직접 thread를 생성하고 사용.  
- OpenMP가 대표적.  

## Threading Issues  

### Semantics of fork() and exec()  
- 유닉스에서는 2개의 fork가 있음.  
- exec는 똑같음.  

### Signal Handling  
- Unix 시스템에서 프로세스에게 특정 이벤트가 일어났다고 알려줌.  
- Process는 Signal Handler를 가지고 있어 이벤트가 일어났을 때 핸들러가 실행됨.  
- Handler는 **default**, **user-defined** 종류가 있음.  
- **user-defined**는 default를 Override해서 사용한다.  

### Thread Cancellation  
- 작업이 끝나기 전 스레드를 종료 종료.  
- **Asynchronous Cancellation**은 즉시 스레드를 종료 시킨다.  
- **Deferred Cancellation**은 순차적으로 종료 시킨다.  

### Thread-Local Storage (TLS)  
- Thread들도 각자의 고유한 전역변수가 필요한 경우가 있음 (배경)    
- Thread 별로 Data 영역처럼 고유의 영역을 제공.  

### Scheduler Activations  
- M:M를 조금 더 효율적으로 사용하는 방법.  
- **Lightweight Process (LWP)** 를 User와 kernel 사이에 둠.  
- LWP를 Activation 시켜서 데이터와 커널의 커뮤니케이션을 원할하게 해줌. (Upcall)    

 
