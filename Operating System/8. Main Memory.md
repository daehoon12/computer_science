# Main Memory  

## Main Memory  
- **Program**은 우리가 작성한 코드가 **프로세스**가 되어 디스크 위에 올라가 있음.  
- CPU는 **Main Mamory와 Register**를 직접 Access 함  

## Base and Limit Registers  
- **logical address space**를 정의해주는 Registers  

## Hardware Address Protection  
- base보다 작거나 base + limit보다 크면 trap 생성  
![캡처](https://user-images.githubusercontent.com/32921115/99766116-d453d880-2b43-11eb-9dba-50a93f2a14be.PNG)

## Address Binding  
- Complied code addresses bind to **relocateble addresses** (위치를 재조정하는 address를 들고 감)  
- Linker or loader가 relocatable addresses와 absolute addresses (실제 주소)를 bind 함  
ex) relocatable address (Offset)가 14 bytes, Start Address가 74000이면 74014로 간다.  

## Logical vs. Physical Address Space  
- Logical Address : CPU가 만든 Address, Virual Address라고도 불림  
- Physical Address : Memory Unit으로 보여지는 Address 
- 이 둘을 엮으려고 **binding**을 함, 보통 **Excution time**에서 Binding을 함  

## Memory-Management Unit (MMU)  
- CPU Core 안에 Virtual Memory를 실제 Memory Address로 변환시켜주는 장치  
- Relocation Register (Base, Limit)
![img](https://user-images.githubusercontent.com/32921115/99767900-3530e000-2b47-11eb-8979-8c4d5c272d95.png)

## Dynamic Relocation  
- 실행될 때 Binding이 일어남  
![캡처](https://user-images.githubusercontent.com/32921115/99768554-4e865c00-2b48-11eb-97a4-696183498eb6.PNG)

## Dynamic Linking  
- Static Linking : Libraries and Program code가 loader에 의해 결합  
- Dynamic Linking : excution time에만 resource에 접근하고 올림  
- Stub : 라이브러리가 메모리에 존재하지 않을 때, 메모리에 상주할 수 있도록 라이브러리 루틴을 적절히 적재하는 방법을 알려주는 작은 코드 조각  
ex) A Library의 a routine이 호출되면 **stub이 루틴 주소로 대체**가 되어, 다음에 그 코드가 한 번 더 수행 될 때는 **Dynamic linking 없이 바로 주소를 참조**해 실행할 수 있게 해줌 -> 즉 런타임 시 해당 루틴이 불리면 루틴이 들어있는 주소값으로 변환 됨 -> 코드가 중복 적재되지 않아 메모리 절약 효과!!

## Swapping  
- Process가 메모리에서 잠깐 뒤 Secondary Storage로 빠졌다가 다시 메모리로 돌아왔다가 이런 식으로 교체  
- Context Switch와 비슷하지만 차이점은 Context Switch는 Main Memory에서 interrupt 요청 등으로 다른 Process를 실행하기 위해 사용된다.  

## Contiguous Memory Allocation (연속 메모리 할당)  
- 비어있는 Main Memory 영역에 Process를 넣음.  
- Memory는 2개의 Partition으로 나뉨.  

## Hardware Support for Relocation and Limit Registers  
![image](https://user-images.githubusercontent.com/32921115/100440039-a04e5980-30e7-11eb-8754-97ccbb3f4ab7.png)
- 그림에서 **logical address**가 limit register보다 작으면 **relocation register**를 더해 그 주소로 process를 Memory에 할당시킴  
- logical address >= limit register 일시 trap 발생

## Memory Allocation  
![image](https://user-images.githubusercontent.com/32921115/100440685-9aa54380-30e8-11eb-89e3-74b4861f7e9a.png)
- Process 8이 종료 되면 메모리 공간이 나오고 relocation은 위 화살표, limit는 아래 화살표  
- 사용 가능한 메모리 블록을 **Hole**이라 함  

## Dynamic Storage-Allocation Problem  
- First-Fit : 이용 가능한 Hole을 찾으면 넣음.  
- Best-Fit : 있는 Hole 중 제일 작은 것에 넣음.  
- Worst-Fit : 제일 넉넉한 Hole을 찾아서 넣음.  

## Fragmentation  
- External Fragmentation (외부 단편화) : Allocation 요청에 충분한 Hole이 있으나, 연속적이지 않게 있다.  - Internal Fragmentation (내부 단편화) : Allocation 요청에 충분한 Hole이 없어 Memory를 사용할 수 없음.  - **External Fragmentation**을 줄이기 위해 **Compaction (압축)** 을 사용한다. 한쪽으로 다 옮겨서 넓은 Hole을 만든다. 하지만 relocation은 dynamic하게 이루어지므로, runtime에서만 가능함.  

## Paging (불연속 메모리 할당)
- Frames : Physical Memory를 일정한 크기의 Block으로 나눠 사용하는 방법. 보통 2의 N승으로 만듬.  
- pages : Logical Memory를 block과 같은 크기로 나눠 사용하는 방법.  
- page로 만들어진 것을 Frame으로 나누어진 할당하기 위해 **Page table**을 사용한다.  
- Overhead가 많이 걸리는 Compaction 대신 사용.  

## Address Translation Scheme  
- Page number (p), Page offset(d)
![image](https://user-images.githubusercontent.com/32921115/100442595-9c243b00-30eb-11eb-86f7-0594bca0a01a.png)
1. logical address에서 page number p를 추출해 page table index로 사용  
2. page table에서 해당 frame 번호 f를 추출  
3. frame의 d의 physical address로 가서 Allocation이 됨.  

## Page Example  
- logical address size = 2^m, Page size = 2^n 일 때, Logical Address의 **상위 m-n 비트는 Page number(p)** 고 나머지는 **page offset(d)** 이다  
- physical Address는 Page size * Frame number를 곱한다.  
- 일종의 동적 재배치 방법  
- page size = 2048 bytes  
- process size = 72,766 bytes = 35 pages + 1086 bytes  
- Internal fragmentation = 2048-1086 = 962 bytes  

## Paging Hardware with TLB  
- Translation Lookaside Buffer (TLB) : 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용되는 캐시  
- TLB에 먼저 접근 뒤 TLB에 없으면 Page Table로 간다.
![image](https://user-images.githubusercontent.com/32921115/100444744-46ea2880-30ef-11eb-86a4-35fa5134a29f.png)

## Effective Access Time  
- Associative Lookup (접근하는데 걸리는 시간) = 입실론 타임  
- Hit Ratio (TLB에서 발견되는 비율) =알파  
![image](https://user-images.githubusercontent.com/32921115/100444868-857fe300-30ef-11eb-90ae-81422db5f794.png)

