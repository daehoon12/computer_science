# Main Memory  

## Main Memory  
- **Program**은 우리가 작성한 코드가 **프로세스**가 되어 디스크 위에 올라가 있음.  
- CPU는 **Main Mamory와 Register**를 직접 Access 함  

## Base and Limit Registers  
- **logical address space**를 정의해주는 Registers  

## Hardware Address Protection  
- base보다 작거나 base + limit보다 크면 trap 생성  
![캡처](https://user-images.githubusercontent.com/32921115/99766116-d453d880-2b43-11eb-9dba-50a93f2a14be.PNG)

## Address Binding  
- Complied code addresses bind to **relocateble addresses** (위치를 재조정하는 address를 들고 감)  
- Linker or loader가 relocatable addresses와 absolute addresses (실제 주소)를 bind 함  
ex) relocatable address (Offset)가 14 bytes, Start Address가 74000이면 74014로 간다.  

## Logical vs. Physical Address Space  
- Logical Address : CPU가 만든 Address, Virual Address라고도 불림  
- Physical Address : Memory Unit으로 보여지는 Address 
- 이 둘을 엮으려고 **binding**을 함, 보통 **Excution time**에서 Binding을 함  

## Memory-Management Unit (MMU)  
- CPU Core 안에 Virtual Memory를 실제 Memory Address로 변환시켜주는 장치  
- Relocation Register (Base, Limit)
![img](https://user-images.githubusercontent.com/32921115/99767900-3530e000-2b47-11eb-8979-8c4d5c272d95.png)

## Dynamic Relocation  
- 실행될 때 Binding이 일어남  
![캡처](https://user-images.githubusercontent.com/32921115/99768554-4e865c00-2b48-11eb-97a4-696183498eb6.PNG)

## Dynamic Linking  
- Static Linking : Libraries and Program code가 loader에 의해 결합  
- Dynamic Linking : excution time에만 resource에 접근하고 올림  
- Stub : 라이브러리가 메모리에 존재하지 않을 때, 메모리에 상주할 수 있도록 라이브러리 루틴을 적절히 적재하는 방법을 알려주는 작은 코드 조각  
ex) A Library의 a routine이 호출되면 **stub이 루틴 주소로 대체**가 되어, 다음에 그 코드가 한 번 더 수행 될 때는 **Dynamic linking 없이 바로 주소를 참조**해 실행할 수 있게 해줌 -> 즉 런타임 시 해당 루틴이 불리면 루틴이 들어있는 주소값으로 변환 됨 -> 코드가 중복 적재되지 않아 메모리 절약 효과!!

## Swapping  
- Process가 메모리에서 잠깐 뒤 Secondary Storage로 빠졌다가 다시 메모리로 돌아왔다가 이런 식으로 교체  
- Context Switch와 비슷하지만 차이점은 Context Switch는 Main Memory에서 interrupt 요청 등으로 다른 Process를 실행하기 위해 사용된다.  

## Contiguous Memory Allocation (연속 메모리 할당)  
- 비어있는 Main Memory 영역에 Process를 넣음.  
- Memory는 2개의 Partition으로 나뉨.  

## Hardware Support for Relocation and Limit Registers  
![image](https://user-images.githubusercontent.com/32921115/100440039-a04e5980-30e7-11eb-8754-97ccbb3f4ab7.png)
- 그림에서 **logical address**가 limit register보다 작으면 **relocation register**를 더해 그 주소로 process를 Memory에 할당시킴  
- logical address >= limit register 일시 trap 발생

## Memory Allocation  
![image](https://user-images.githubusercontent.com/32921115/100440685-9aa54380-30e8-11eb-89e3-74b4861f7e9a.png)
- Process 8이 종료 되면 메모리 공간이 나오고 relocation은 위 화살표, limit는 아래 화살표  
- 사용 가능한 메모리 블록을 **Hole**이라 함  

## Dynamic Storage-Allocation Problem  
- First-Fit : 이용 가능한 Hole을 찾으면 넣음.  
- Best-Fit : 있는 Hole 중 제일 작은 것에 넣음.  
- Worst-Fit : 제일 넉넉한 Hole을 찾아서 넣음.  

## Fragmentation  
- External Fragmentation (외부 단편화) : Allocation 요청에 충분한 Hole이 있으나, 연속적이지 않게 있다.  - Internal Fragmentation (내부 단편화) : Allocation 요청에 충분한 Hole이 없어 Memory를 사용할 수 없음.  - **External Fragmentation**을 줄이기 위해 **Compaction (압축)** 을 사용한다. 한쪽으로 다 옮겨서 넓은 Hole을 만든다. 
