# Main Memory  

## Main Memory  
- **Program**은 우리가 작성한 코드가 **프로세스**가 되어 디스크 위에 올라가 있음.  
- CPU는 **Main Mamory와 Register**를 직접 Access 함  

## Base and Limit Registers  
- **logical address space**를 정의해주는 Registers  

## Hardware Address Protection  
- base보다 작거나 base + limit보다 크면 trap 생성  
![캡처](https://user-images.githubusercontent.com/32921115/99766116-d453d880-2b43-11eb-9dba-50a93f2a14be.PNG)

## Address Binding  
- Complied code addresses bind to **relocateble addresses** (위치를 재조정하는 address를 들고 감)  
- Linker or loader가 relocatable addresses와 absolute addresses (실제 주소)를 bind 함  
ex) relocatable address (Offset)가 14 bytes, Start Address가 74000이면 74014로 간다.  

## Logical vs. Physical Address Space  
- Logical Address : CPU가 만든 Address, Virual Address라고도 불림  
- Physical Address : Memory Unit으로 보여지는 Address 
- 이 둘을 엮으려고 **binding**을 함, 보통 **Excution time**에서 Binding을 함  

## Memory-Management Unit (MMU)  
- CPU Core 안에 Virtual Memory를 실제 Memory Address로 변환시켜주는 장치  
- Relocation Register (Base, Limit)
![img](https://user-images.githubusercontent.com/32921115/99767900-3530e000-2b47-11eb-8979-8c4d5c272d95.png)

## Dynamic Relocation  
- 실행될 때 Binding이 일어남  
![캡처](https://user-images.githubusercontent.com/32921115/99768554-4e865c00-2b48-11eb-97a4-696183498eb6.PNG)

## Dynamic Linking  
- Static Linking : Libraries and Program code가 loader에 의해 결합  
- Dynamic Linking : excution time에만 resource에 접근하고 올림  
- Stub : 라이브러리가 메모리에 존재하지 않을 때, 메모리에 상주할 수 있도록 라이브러리 루틴을 적절히 적재하는 방법을 알려주는 작은 코드 조각  
ex) A Library의 a routine이 호출되면 **stub이 루틴 주소로 대체**가 되어, 다음에 그 코드가 한 번 더 수행 될 때는 **Dynamic linking 없이 바로 주소를 참조**해 실행할 수 있게 해줌 -> 즉 런타임 시 해당 루틴이 불리면 루틴이 들어있는 주소값으로 변환 됨 -> 코드가 중복 적재되지 않아 메모리 절약 효과!!
