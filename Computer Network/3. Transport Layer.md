# Transport Layer  

## Transport Layer  
- 하나의 프로세스에서 다른 프로세스로 **Message**를 보내는 Layer  
- Newwork Layer에 의존해 **Process 간의 Communication을 담당**하는 Layer  
- Messege를 Segment로 나누어 Network Layer로 전송함  
- Internet : TCP, UDP 프로토콜  

## Multiplexing / Demultiplexing  
- Multiplexing : 소켓들로부터 Data를 모으고, 헤더 정보를 포함한 Segment들을 Network Layer에 전달  
- Demultiplexing : 헤더 정보를 사용해 수신된 Segment들을 올바른 Socket에 전달  

### 비연결형 Multiplexing/Demultiplexing  

![image](https://user-images.githubusercontent.com/32921115/104997035-483f2e00-5a6c-11eb-8969-628e360c0135.png)

- UDP Socket : Port Number, IP 주소  
- Host가 UDP 세그먼트를 보낼 때 **Port number만 확인하고 해당 번호를 갖는 Socket에 Segment를 보냄**.  

### 연결형 Multiplexing/Demultiplexing  

![image](https://user-images.githubusercontent.com/32921115/104997176-7d4b8080-5a6c-11eb-8139-4955142eabb6.png)

- 4개의 요소를 가짐, source IP, Port Number, Dest IP, Port Number  
- 4개의 값을 사용해 해당 소켓으로 segment 전달  
- Web Server는 **연결되는 각 클라이언트마다 다른 소켓을 가짐 (비지속 HTTP의 특징)**  

## UDP (User Datagram Protocol)  
- IP에 최소 기능만 추가  
- Best Effort Service (노력은 하지만 결과는 보장하지 않는다) : 최대한 순서대로 보낼려고 노력은 하는데 보장은 안함.  
- Connectionless : 송수신간 Handshake 사용 안함  
- 보통 스트리밍 서비스에서 사용한다.  

## TCP  
- 비신뢰적인 IP 서비스 위에서 신뢰성있는 데이터 전송을 서비스함  
- point-to-point, reliable, in-order byte stream, flow controlled, congestion controlled, connection-oriented  
 
 ### TCP Connection  
 - TCP Sender, Receiver는 Segment 교환 전에 Handwhake를 함  
 - 클라이언트는 연결 요청, 서버는 클라이언트의 요청을 승인  
 
 ### Example  

![image](https://user-images.githubusercontent.com/32921115/104998632-e8965200-5a6e-11eb-9436-2a49efb035be.png)

- Client는 Server에게 접속을 요청하는 SYN 패킷을 보내고 SYN/ACK를 기다리는 SYN_SENT 상태가 됨  
- 서버는 SYN 요청을 받고 Client에게 ACK와 SYN flag를 보냄.  
- Client는 ACK를 보내고 이후 연결이 이루어지고 데이터가 오가게 된다.  

